#!/usr/bin/env perl

use strict;
use warnings;

# split from from 'newperl', because perlbrew exec has problems handling
# local::lib directories when we're not actually in that perl directly

my $start_time = time();

use File::Basename;
sub part(&@);

# TODO: these should all be in Task::BeLike::ETHER

my @install_first = qw(
    App::cpanminus::reporter
);
my @to_install = (
qw(
    App::cpanminus
    Alt::Module::Runtime::ButEUMM
    ExtUtils::MakeMaker
    JSON::PP
    CPAN::Meta
    CPAN::Meta::Requirements
    Parse::CPAN::Meta
    Test::Pod
    Test::Pod::Coverage
    App::Ack
    App::Nopaste
    App::cpanoutdated
    App::pmuninstall
    App::cpangrep
    App::PAUSE::Comaint
    Module::CoreList
    CPAN::Perl::Releases
    Unicode::Tussle
    App::Uni
    Test::CPAN::Meta
    Data::Dumper
    local::lib
    App::FatPacker
    PPI::XS
    Text::CSV_XS
    Archive::Tar::Wrapper
    LWP::Protocol::https
    Unicode::UTF8
    Devel::Confess
    Devel::TraceUse
    Devel::PatchPerl
    Devel::Dwarn
    Devel::Hide
    Devel::Cover
    Test::DiagINC
    Acme::require::case
    Safe::Isa
    Cpanel::JSON::XS JSON::MaybeXS
    YAML::Syck
    indirect multidimensional bareword::filehandles
    strictures
    Role::Tiny Package::Variant Moo
    Text::Diff
    Dist::Zilla::Plugin::Chrome::ExtraPrompt
    Dist::Zilla::Plugin::Bootstrap::lib
    Dist::Zilla::App::Command::dumpphases
    Dist::Zilla::App::Command::podpreview
    Dist::Zilla::App::Command::dumpwith
    Dist::Zilla::App::Command::lsplugins
    Dist::Zilla::App::Command::cover
    Dist::Zilla::Plugin::SurgicalPodWeaver
    Dist::Zilla::Plugin::Prereqs::Soften
    Dist::Zilla::Plugin::MungeFile::WithDataSection
    Dist::Zilla::Plugin::OnlyCorePrereqs
    Dist::Zilla::Plugin::CheckBin
    Dist::Zilla::Plugin::CheckLib
    Dist::Zilla::Plugin::AssertOS
    Dist::Zilla::Plugin::NoAutomatedTesting
    Dist::Zilla::Plugin::GenerateFile::ShareDir
    Dist::Zilla::Plugin::DynamicPrereqs
    Dist::Zilla::Plugin::OptionalFeature
    Dist::Zilla::Plugin::Test::PAUSE::Permissions
    ExtUtils::MakeMaker::Dist::Zilla::Develop
    Dist::Zilla::Plugin::PPPort
    Dist::Zilla::Plugin::ReportPhase
    Dist::Zilla::Plugin::VerifyPhases
    Dist::Zilla::Plugin::BlockRelease
    Dist::Zilla::Plugin::Prepender
    Dist::Zilla::Plugin::Covenant
    Dist::Zilla::Plugin::Conflicts
    Dist::Zilla::Plugin::Breaks
    Dist::Zilla::Plugin::Test::CheckBreaks
    Dist::Zilla::Plugin::MungeFile::WithConfigFile
    Dist::Zilla::Plugin::Prereqs::Soften
    Dist::Zilla::Plugin::PodVersion
    Dist::Zilla::Plugin::Deprecated
    Dist::Zilla::Plugin::CheckVersionIncrement
    Dist::Zilla::Plugin::Test::Version
    Dist::Zilla::Plugin::EnsurePrereqsInstalled
    Dist::Zilla::Plugin::Test::Synopsis
    Dist::Zilla::Plugin::Substitute
    Dist::Zilla::Plugin::SmokeTests
    Test::DistManifest
    Test::RequiresInternet
    Pod::Coverage::TrustPod
    Pod::Coverage::Moose
    Dist::Zilla::PluginBundle::Author::ETHER
    Pod::Weaver::Section::AllowOverride
    Module::Install
    Module::Install::Repository
    Module::Install::AuthorRequires
    Module::Install::ReadmeFromPod
    Module::Install::GithubMeta
    Module::Install::AutoLicense
    Dist::Zilla::PluginBundle::RJBS
    perlsecret
    Parse::PMFile
    V
    Module::Info
    Module::InstalledVersion
    Module::Version
    DateTime
    DateTime::TimeZone
    DateTime::Format::ISO8601
    Module::CoreList
    Plack
),
# distributions that I call "mine"
(map { (my $mod = basename($_)) =~ s/-/::/g; $mod } glob('~/git/mydists/*')),

# distributions where ETHER is first-come in PAUSE
(map { s/,ETHER,[fm]//;s/-/::/g; $_ } split(/\n/, `grep ',ETHER,[fm]' ~/.cpanm/06perms.txt`))
);


# dev versions known to fail
my @install_no_dev = qw(
    Test::Builder
);

my @serial_tests = qw(
    File::Next
    IO::Pty
    Parse::CPAN::Packages::Fast
    File::Slurp
    Test::Inline
    Storable
    File::ShareDir::Install
    IO::Zlib
);

my @fails_tests = qw(
);

my @with_dev_recommends = qw(
    ExtUtils::MakeMaker
    Module::Metadata
    Moose
    Dist::Zilla::PluginBundle::Author::ETHER
);

print `perl -v`;

run( qw/yes | perlbrew install-cpanm/ );

# avoid my cpanm alias which invokes cpanm-reporter (in whatever perl is
# currently active)
chomp(my $cpanm = `which cpanm`);

my @cpanm = ($cpanm,
# do not use until output is less spammy, and cpanm-reporter knows how to
# process file:/// URLs
#qw(
#    --cascade-search
#    --save-dists /Volumes/amaretto/Users/ether/.cpanm/cache
#    --mirror /Volumes/amaretto/Users/ether/.cpanm/cache
#    --mirror http://mirrors.gossamer-threads.com/CPAN/
#)
);

# until I add option parsing, hack this to turn on/off dev installs.
my $dev = '--dev';
#my $dev = '';

## let's avoid any pod tests when we try to install stuff
#system( @cpanm 'TAP::Harness::Restricted' );
#local $ENV{HARNESS_SUBCLASS} = "TAP::Harness::Restricted";

# now install the rest

my (@success, @failed);

my $separately = shift;

if ($separately)
{
    # this is crude but will do for now...
    print "argument detected - skipping to installing each module separately\n";
    goto SEPARATELY;
}

run_or_die(@cpanm, @install_first);
run_or_die('cpanm-reporter');


## first pre-pass - ensure Test::Tester and ok are installed as stable, to
## avoid having Test::More upgraded to trial unduly.
#run("@cpanm --mirror http://www.cpan.org Test::Tester ok");
#run('cpanm-reporter');

## on the first big pass, just try to install my pluginbundle, using
## default HARNESS_OPTIONS, trial/developer releases of everything upstream if there are any
#run("EXTRA_TESTING=1 @cpanm $dev --mirror http://www.cpan.org Dist::Zilla::PluginBundle::Author::ETHER");
#run('cpanm-reporter');

# install things we know to fail when installed in parallel...
# we try to install them in parallel first to get their prereqs in parallel.
run(@cpanm, @serial_tests);
run('cpanm-reporter');
run("HARNESS_OPTIONS=j1 @cpanm @serial_tests");
run('cpanm-reporter');

# in the first big pass, try to install everything in one process, using
# default HARNESS_OPTIONS, trial/developer releases if there are any
run("EXTRA_TESTING=1 @cpanm $dev --mirror http://www.cpan.org @to_install @fails_tests");
run('cpanm-reporter');

# now try again to install things whose tests are known to fail
run(@cpanm, '--notest', @fails_tests) if @fails_tests;
run('cpanm-reporter') if @fails_tests;

run("EXTRA_TESTING=1 @cpanm --mirror http://www.cpan.org @to_install @fails_tests");
run('cpanm-reporter');

run(@cpanm, '--with-recommends', '--with-develop', $dev, @with_dev_recommends);
run('cpanm-reporter');

SEPARATELY:

run("moose-outdated | @cpanm $dev --mirror http://www.cpan.org");
run('cpanm-reporter');

use Module::CoreList; # requires 2.22
my $in_core = Module::CoreList->find_version($]);
run(@cpanm, grep { !/win32/i } keys %$in_core);
run('cpanm-reporter');

run(@cpanm, $dev, grep { !/win32/i } keys %$in_core);
run('cpanm-reporter');

goto DONE if not $separately;

print "\n\ninstalling again, to handle circular dependencies, and things that didn't install cleanly (WATCH FOR THESE!)...\n";

# try installing everything again, stable releases this time, to handle circular deps, parallelization problems
my @results = part {
    my $result = run("HARNESS_OPTIONS=j1 @cpanm", $_[0]);
    run('cpanm-reporter');
    $result ? 0 : 1;
} (@install_first, @install_no_dev, @to_install, @fails_tests);
push @success, @{$results[0]};
push @failed, @{$results[1] || []};

print 'Failed attempts to install:', join("\n    ", '', @failed), "\n\n";

print "SUCCESS!!!\n\n" if not @failed;

DONE:

my $elapsed_time = time() - $start_time;
my ($min, $sec) = (int($elapsed_time / 60), $elapsed_time % 60);
print "done (elapsed time: ${min}m ${sec}s).\n";
system(say => 'done.');
system(say => "elapsed time: ${min} minutes, ${sec} seconds.");

sub part(&@)
{
    my $sub = shift;
    my (@true, @false);

    foreach my $element (@_)
    {
        my $res = $sub->($element);
        push @true, $element if $res;
        push @false, $element if not $res;
    }
    return \@true, \@false;
}

sub run_or_die
{
    my $cmd = join(' ', @_);
    print "\nRunning: $cmd\n";
    system $cmd;
    die "$cmd returned exit code $?: stopping" if $?;
    return $?
}

sub run
{
    my $cmd = join(' ', @_);
    print "\nRunning: $cmd\n";
    system $cmd;
    warn "$cmd returned exit code $?" if $?;
    return $?
}

